#!/usr/bin/env ruby

require 'optparse'

$plain = false
$opts = OptionParser.new do |opts|
  opts.banner = <<-END
Usage: n [options] number [operation number...]

Options:
END

  opts.on("-p", "--plain", "Don't add underscores for readability") do |v|
    $plain = true
  end
end
$opts.parse!

def usage
  puts $opts.help
  exit 1
end

# convert number to string with given base
def to_base(number, base)
  prefix = ''
  suffix = ''

  prefix = '0x' if base == 16
  prefix = '0' if base == 8

  if $plain
    prefix + number.to_s(base)
  else
    z = number.to_s(base).reverse.scan(/.{1,4}/)
    z = z.map { |e| e.reverse }

    prefix + z.reverse.join('_')
  end
end

# convert string to number using its prefix/suffix as base indication
def to_dec(number)
  return number unless number =~ %r{\A[\d\w]+\z}

  number = number.gsub(/_/, '')
  ibase = 10

  # try to deduce base from prefix
  case number
  when /^0x/
    ibase = 16
  when /^0\d/
    ibase = 8
  end

  # suffix takes precedence
  case number
  when /h$/
    ibase = 16
  when /o$/
    ibase = 8
  when /d$/
    ibase = 10
  when /b$/
    ibase = 2
  end

  begin
    Integer(number, ibase)
  rescue Exception
    puts 'Invalid number'
    exit 2
  end
end

# convert to given units
def humanify(n, power, units)
  unit = 0
  mod = 0

  mod_power = power / 10
  mod_power += 1 if power % 10 != 0

  while n >= power and unit < units.size - 1
    mod = n % power
    n = n / power
    unit += 1
  end

  if mod != 0
    "#{n}.#{mod / mod_power}#{units[unit]}"
  else
    "#{n}#{units[unit]}"
  end
end

usage if ARGV.size == 0 || ARGV[0] == '-h'

args = ARGV.join.scan(/[\d\w]+|[-+*\/%()^&|!]|<<|>>/)
args = args.map { |e| to_dec(e) }

case args.size
when 0
  usage
when 1
  n = to_dec(args[0])
else
  begin
    n = eval(args.join)
  rescue Exception
    puts 'Invalid expression'
    exit 1
  end
end

converted = {
  bin: to_base(n, 2),
  oct: to_base(n, 8),
  dec: to_base(n, 10),
  hex: to_base(n, 16)
}

bp =  humanify(n, 1024, [ '', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB' ])
dp =  humanify(n, 1000, [ '', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB' ])

len = converted.map { |k, v| v.length }.max

converted.each do |k, v|
  case k
  when :dec
    puts "#{converted[:dec].rjust(len)} #{bp} #{dp}"
  else
    puts converted[k].rjust(len)
  end
end
