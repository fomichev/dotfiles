#!/bin/sh

usage() {
	cat <<END
Usage: g [options] [--] [pattern...]

Options:
  -s            Skip ~/.grc and ./.grc loading
  -l            Print only names of files containing matches
  -i            Ignore case
  -v            Invert match: select only non-matched lines
  -w            Match the pattern only at word boundary
  -g            Use regular grep even in git repository
  -p <pattern>  Search files that match given pattern
END
}

git_grep_opts='-nI'
git_grep_pathspec=''
find_opts="! -path '*.o.cmd' ! -path '*.swp' ! -path '*~' ! -path '*.a' ! -path '*.o' ! -path '*/tags' ! -path '*/ipkg-*' ! -path '*/.deps' ! -path '*/autom4te.cache*' ! -path '*/.git*' ! -path '*/.hg*' ! -path '*/.svn*'"
grep_opts='-nI'
grep_variant=

if [ -t 1 ]; then
	[ -z $PAGER ] && { PAGER='less -r'; }

	pager="| $PAGER"
	export GIT_PAGER=$PAGER
	git_grep_opts="$git_grep_opts --color=always"
	grep_opts="$grep_opts --color=always"
else
	pager=
	grep_opts="$grep_opts --color=never"
	git_grep_opts="$git_grep_opts --color=never"
	export GIT_PAGER=''
fi

ARGS=`getopt -o 'slivwgp:h' -n 'g' -- "$@"`
[ ! $? -eq 0 ] && { exit $?; }
eval set -- $ARGS

load_rc=1

while true; do
	case "$1" in
	--)
		shift
		break
		;;

	-s)
		load_rc=0
		shift
		;;

	-l)
		grep_opts="$grep_opts -l"
		git_grep_opts="$git_grep_opts -l"
		shift
		;;

	-w)
		grep_opts="$grep_opts -w"
		git_grep_opts="$git_grep_opts -w"
		shift
		;;

	-i)
		grep_opts="$grep_opts -i"
		git_grep_opts="$git_grep_opts -i"
		shift
		;;

	-v)
		grep_opts="$grep_opts -v"
		git_grep_opts="$git_grep_opts -v"
		shift
		;;

	-p)
		find_opts="-path './$2'"
		git_grep_pathspec="-- '$2'"
		shift
		shift
		;;

	-g)
		grep_variant=system
		shift
		;;

	*|-h)
		usage
		exit
		;;
	esac
done

# Some kind of 'API' which can be safely used in .grc {{{
find_exclude() { find_opts="$find_opts ! -path '$1'"; }
force_grep_variant() { grep_variant=$1; }
# }}}

if [ $load_rc -eq 1 ]; then
	[ -r ~/.grc ] && { . ~/.grc; }
	[ -r ./.grc ] && { . ./.grc; }
fi

grep_pattern=$@

git_grep() {
	`git rev-parse --show-toplevel &>/dev/null`
	[ ! $? -eq 0 ] && return

	exec git grep $git_grep_opts -e "$grep_pattern" $git_grep_pathspec
}

system_grep() {
	exec sh -c "find . -type f $find_opts -print0 | xargs --null grep $grep_opts -e \"$grep_pattern\" 2>/dev/null $pager"
}

case $grep_variant in
	system) system_grep ;;
	*) git_grep; system_grep ;;
esac
