#!/bin/sh

usage() {
	cat <<END
Usage: g [options] [--] [pattern...]

Options:
  -s            Skip ~/.grc and ./.grc loading
  -l            Print only names of files containing matches
  -i            Ignore case
  -v            Invert match: select only non-matched lines
  -w            Match the pattern only at word boundary
  -g            Use regular grep even in git repository
  -p <pattern>  Search files that match given pattern
END
}

# Some kind of 'API' which can be safely used in .grc {{{
find_exclude() { [ -z "$find_excl_opts" ] && { find_excl_opts="-path '*/$1'"; } || { find_excl_opts="$find_excl_opts -o -path '*/$1'"; }; }
find_include() { [ -z "$find_incl_opts" ] && { find_incl_opts="-path '*/$1'"; } || { find_incl_opts="$find_incl_opts -o -path '*/$1'"; }; }
force_grep_variant() { grep_variant=$1; }
# }}}

git_grep_opts='-nI'
git_grep_pathspec=''
find_excl_opts=''
find_incl_opts=''
grep_opts='-nI'
grep_variant=

find_exclude '*~'
find_exclude '*.swp'
find_exclude '*.a'
find_exclude '*.o'
find_exclude '*.o.d'
find_exclude '*.o.cmd'

find_exclude 'autom4te.cache/*'
find_exclude 'config.log'
find_exclude 'config.status'

find_exclude 'tags'
find_exclude 'ipkg-*'

find_exclude '.deps/*'
find_exclude '*.a.deps'

find_exclude '.git/*'
find_exclude '.hg/*'
find_exclude '.svn/*'

if [ -t 1 ]; then
	[ -z $PAGER ] && { PAGER='less -r'; }

	pager="| $PAGER"
	export GIT_PAGER=$PAGER
	git_grep_opts="$git_grep_opts --color=always"
	grep_opts="$grep_opts --color=always"
else
	pager=
	grep_opts="$grep_opts --color=never"
	git_grep_opts="$git_grep_opts --color=never"
	export GIT_PAGER=''
fi

ARGS=`getopt -o 'slivwgp:h' -n 'g' -- "$@"`
[ ! $? -eq 0 ] && { exit $?; }
eval set -- $ARGS

load_rc=1

while true; do
	case "$1" in
	--)
		shift
		break
		;;

	-s)
		load_rc=0
		shift
		;;

	-l)
		grep_opts="$grep_opts -l"
		git_grep_opts="$git_grep_opts -l"
		shift
		;;

	-w)
		grep_opts="$grep_opts -w"
		git_grep_opts="$git_grep_opts -w"
		shift
		;;

	-i)
		grep_opts="$grep_opts -i"
		git_grep_opts="$git_grep_opts -i"
		shift
		;;

	-v)
		grep_opts="$grep_opts -v"
		git_grep_opts="$git_grep_opts -v"
		shift
		;;

	-p)
		find_include "$2"
		git_grep_pathspec="-- '$2'"
		shift
		shift
		;;
	-g)
		grep_variant=system
		shift
		;;

	*|-h)
		usage
		exit
		;;
	esac
done

if [ $load_rc -eq 1 ]; then
	[ -r ~/.grc ] && { . ~/.grc; }
	[ -r ./.grc ] && { . ./.grc; }
fi

grep_pattern=$@

git_grep() {
	`git rev-parse --show-toplevel &>/dev/null`
	[ ! $? -eq 0 ] && return

	exec git grep $git_grep_opts -e "$grep_pattern" $git_grep_pathspec
}

system_grep() {
	local find_opts=''
	[ -z "$find_incl_opts" ] && { find_opts="\( $find_excl_opts \) -prune -o \( -type f -print0 \)"; } || { find_opts="-type f $find_incl_opts -print0"; }

	exec sh -c "find . $find_opts | xargs --null grep $grep_opts -e \"$grep_pattern\" 2>/dev/null $pager"
}

case $grep_variant in
	system) system_grep ;;
	*) git_grep; system_grep ;;
esac
